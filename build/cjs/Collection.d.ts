import ActiveRecord from './ActiveRecord.js';
import CollectionIterator from './CollectionIterator.js';
import HttpRequest from './Http/Request.js';
import Model from './Model.js';
import { IAttributes, ICollectionMeta, IDispatcherEvent, IPagination } from './Interfaces.js';
export default class Collection<GenericModel extends Model> extends ActiveRecord<Collection<GenericModel>> implements Iterable<GenericModel> {
    static paginator(collection: any): IPagination;
    static hydrate<T>(models?: Model[] | any, options?: object, trigger?: boolean): any;
    protected get isCollection(): boolean;
    get length(): number;
    get modelId(): string;
    get pagination(): IPagination;
    atRelationship: string[];
    _meta: ICollectionMeta;
    model: GenericModel;
    models: GenericModel[];
    protected sortKey: string;
    private iterator;
    constructor(options?: IAttributes);
    toJSON(): object;
    fetchNext(append?: boolean): Promise<HttpRequest>;
    fetchPrevious(append?: boolean): Promise<HttpRequest>;
    getEndpoint(): string;
    add(data: GenericModel[] | GenericModel | object, options?: IAttributes, trigger?: boolean): this;
    remove(model: Model[] | Model | object, trigger?: boolean): this;
    set(model: Model[] | Model | object, options?: IAttributes, trigger?: boolean): this;
    clear(): this;
    count(): number;
    delete(attributes?: any): Promise<HttpRequest>;
    each(callback: any): void;
    filter(predicate: any): GenericModel[];
    map(...params: any): any[];
    push(model: Model[] | Model | object, options?: object): Collection<GenericModel>;
    pop(): this;
    reset(): this;
    unshift(model: GenericModel[] | GenericModel | object, options?: IAttributes): this;
    shift(): this;
    shuffle(): this;
    reverse(): Collection<GenericModel>;
    slice(...params: any): GenericModel[];
    unique(): this;
    get(query: GenericModel | number | string): Model | undefined;
    has(obj: GenericModel | number | string): boolean;
    at(index?: number): GenericModel;
    first(): GenericModel;
    last(): GenericModel;
    where(json?: IAttributes, first?: boolean, fullMatch?: boolean): this | Collection<GenericModel> | GenericModel;
    findWhere(attributes?: IAttributes): GenericModel;
    findByCid(cid: string): GenericModel;
    sort(options?: IAttributes): Collection<GenericModel>;
    pluck(attribute: string): any;
    values(filter?: (model: GenericModel, index: number) => boolean): CollectionIterator<GenericModel>;
    keys(filter?: (model: GenericModel, index: number) => boolean): CollectionIterator<GenericModel>;
    entries(filter?: (model: GenericModel, index: number) => boolean): CollectionIterator<GenericModel>;
    next(filter?: (model: GenericModel, index: number) => boolean): GenericModel | undefined;
    previous(filter?: (model: GenericModel, index: number) => boolean): GenericModel | undefined;
    index(): number;
    current(filter?: (model: GenericModel, index: number) => boolean): GenericModel | undefined;
    resetIterator(): void;
    indexOf(model: GenericModel): number;
    [Symbol.iterator](): any;
    protected Handle_OnChange(e: IDispatcherEvent): void;
}
